# 概要
『Backrooms Hole ～Backroomsの穴～』は自作ゲームの開発で使っている共通システムのソースコードを公開するために、サンプル・技術デモを目的として作成された脱出ゲームです。  
探索向け・ウォーキングシミュレーター向けの機能を中心に実装している共通システムで、ホラーゲームや脱出ゲームの開発の雛形や参考になれば幸いです。  

# 注意
ゲームのソースコードは公開しますが、一般向けに全ての実装に対してマニュアルを作成したり、個別の質問に対応するのは負担が大きいすぎるので、基本的にサポートは期待しないでください。  
ゲームの実際動作とそのプログラミング箇所を見つけて、改造・コピペ・真似するつもりくらいの気持ちでご活用いただければと思います（ソースコードは自作ゲーム開発用作成したもののため、一部に未削除の使っていない処理などが残っている可能性があります）。  

解説を行っている実装に関しても基本的な使い方に留め、細かい解説は複雑かつ上級者向けになるため割愛しているものもあります。  

マルチプレイには未対応で、モバイル端末やロースペックPCへの最適化を行っていないのでそれらの端末向けのゲームには適さない可能性があります。  

なおUnreal Engineで作成したゲームのソースコードに過ぎず、ツクール系のようなゲームを作れるゲームとは違い、このソースコードを雛形・参考にすればゲームを誰でも簡単に作れるようになるわけではありません。  
プログラミングやゲーム開発が初心者の方は、ゲームエンジン（Unreal Engine）のインストールからはじめ、その使い方なども勉強する必要はあります。  

# 初心者の方へ

はじめは自作ゲームを作るといった高い目標でなく、まずはこのゲームを改造して遊ぶといった感じでも良いと思います。  

Unreal Engineのライセンスは大雑把に説明すると1億円売上るまでは無料で、その無料の範囲内には高品質の3Dモデルやキャラクターなどが多数含まれています。  
まずはそれらをゲームマップ上に配置して遊ぶことからはじめてみてはどうでしょう。  

私がUnreal Engineをはじめた頃にこのソースコードがあったとしたら、そんなところからはじめますし、そんなことくらいからしかできませんでした。  

私自身、Unreal Engineではじめて作ったゲームは、頂上のゴールをジャンプで目指すだけの単純なものでした（ジャンプやゴールのサンプルはあったので、無料の3Dモデルを配置すれば作れそうだったゲーム）。  
まずはUnreal Engineの使い方を知り、ゲームの完成からリリースまでを経験するためと割切りました。  

# プログラミング用語

一部でプログラミング用語を用いている箇所もあり、プログラミング経験者でも言語によっては馴染みのないものありますし、言語によっては同じ名称でも仕様が異なっているものもあるかもしれません。  
そもそも私の誤用などもあるかもしれません。  

## 継承・オーバーロード

Unreal Engineの開発では基本的に何かしらのクラスを「継承」してプログラミングすることになります（そもそも「クラス（Class）」からわからない人もいるでしょうが私は上手く説明することができないので割愛します）。

継承される元となるクラスを親クラス（Parent）と呼び、継承する側のクラスを子クラス（Child）と呼びます。  
ほとんどのクラスが何かしらのクラスを継承しており、何かしらの親クラスが存在します。  

継承で重要なポイントは、ただ親クラスを継承しただけの子クラスは変数やイベント・関数をそのまま継承（引き継いで）しており、同じように動作します。  

そして一部の変数やイベント・関数を子クラスで変更・追加したいような場合に「オーバーライド」してカスタマイズします。  

コピペと違い一部だけカスタマイズする感じなので、子クラスでは基本的にそのカスタマイズする箇所のみ実装するだけで済みます。  
実装を後から読み解くような時でも、親クラスと異なる箇所のみ実装されているので多少楽です。  

それに親クラス側で実装を変更した場合でも、子クラスでオーバーラードしていない箇所が影響しないものなら小クラスを修正する必要はありません（これは親クラス側の仕様変更によってケースバイケースです）。  
もし継承ではなくコピペだった場合は、親クラスにあたるコピペ元の実装を変更した場合、子クラスに当たるコピペ先の該当する箇所を子クラスの数だけ同じように変更する手間が発生します。  

## （変数の）型

プログラミングでは複数の数値や文字などあらゆる情報を変数という形で扱います。  

そしてUnreal Engineではその変数はどのようなタイプの情報（値）であるかをある程度識別できるように型で管理しています。  
数値でもInteger型やFloat型など種類があって扱える数値の桁数などが異なりますし、文字列でも単純に文字列として扱うString型から多言語（日本語と英語など）の切り替えに対応したText型などがあります。  

またクラスも変数として扱うことができます。  

仮に人間クラス型があって、それを継承するゲーム開発者クラス型とゲーム実況者クラス型という子クラスがあるとします。  
この場合、ゲーム開発者クラス型とゲーム実況者クラス型は人間クラス型の変数として扱うことができます。  
しかしゲーム開発者クラス型の変数ではゲーム実況者クラス型を扱うことはできます。逆のパーンも同様です。  

親クラスである人間クラス型変数として値を抽象的に扱うことで、異なる型のクラスの値を同じ型の変数で管理することができ、プログラミングの実装に柔軟性を持たせることが可能になります。  
時には柔軟性があるままだと一部のクラスの処理を実行できないもありますが、Unreal Engineでは基本システムとしてこの抽象的にクラスを扱う仕様になっているようで、押さえておきたいポイントです（例: GameInstacePlayerController、HUD、Character、GameState、PlayerState等々）。  

例えばゲーム実況者クラスに実装されているライブ配信イベントを実行したい時、人間クラス型変数からは直接そのライブ配信イベントを実行することができません。  
ここで必要になるのがキャストもしくはインターフェースになります。  

### Boolean型

TrueかFalseかのどちらかの値を持てる型で、オン・オフを管理する場合などに多く用いられます。  

値の指定はチェックボックスにチェックを入れるかどうかで指定できます。  
チェックが入っている場合はTrueとなり、有効意味することが多いと思います。  

ただし変数名がLockedとUnlockedであればどちらもTrueになっていたとしても意味は正反対になりますし、単純にTrueだからと言って肯定的な状態を指すわけではないことに注意してください。  

### キャスト（Cast） / インターフェース（Interface）

Unreal Engineでの開発向けの解説では現在の変数の型のままでは特定の変数・イベント・関数を扱えない場合、キャストする方法が多いように感じます。  

こちらでも良いのですが、このゲームでは基本的にインターフェースで行っています。  
インターフェースで行う場合、クラスファイル以外にインターフェース用のファイルを作って、かつこのインターフェースを使うクラスに設定し、さらにそのインターフェースのイベント・関数をその関数に実装する手間があります。  

ただ個人的な経験から、過去に作ったゲームのプログラムを流用する時にキャストしている箇所の修正が思いのほか手間に感じたので、極力、インターフェースで対応する方針にしました。  
そのためこのゲームプログラムではキャストの箇所は圧倒的に少なく、逆にインターフェースを多用しています。  

特にインターフェースであれば一部を同じような役割をする全く異なるプログラムに置き換える場合も、そのインターフェース経由で実行できるようにすることで、プログラム全体ではほとんど修正不要で実施することが可能になると判断しました。  
ゲーム開発の経験を重ねる中で新しい知識や技術を得、既存の自作プログラムを修正することも少なくありません。このような時でもシステム全体を修正することなく、新しいプログラムに置き換えやすくなります。  

この点に関しては私自身のゲーム開発が独学で、他のゲーム開発プロジェクトなどの経験がないため、キャストとインターフェースのどちらがベスト・ベターなのかといった判断は難しいです。  
そもそも私の専門はプログラミングというわけではないので、プログラミングを専門にしている方の意見も参考にしたいところではあります。  

# 動作環境
Unreal Engine 5.1  

Unreal Engineのバージョンが異なっている場合は正常に動作しない可能性が高くなります。  

## 追加プラグイン

標準搭載されているプラグインですが、初期設定では無効になっていることがあり、無効のままだと正常に動作しません。  

### Common UI Plugin
テキストやボタンの共通スタイルなどで使用。  

### Gameplay Abilities
現時点では主にGameplayTagをフラグとして使っているだけです。  

# 導入
1. Unreal Engineのインストール  
2. 新規プロジェクトの作成  
3. BackroomsHoleのソースコードでプロジェクトを上書き  
4. プロジェクトをUnreal Engineエディタで開く  

なおこの導入手順はGitHubにアップロードできるソースコードを各々の端末にダウンロードして、Unreal Engineのエディタ上で編集したり動作させたりパッケージ化させたりするためのものになります。  
通常のUnreal Engineでの使用方法とは異なっている可能性があります。  

## 1. Unreal Engineのインストール
Unreal Engineの公式サイトなどを参考にUnreal Engineでゲーム開発できるように環境構築を行います。  

## 2. 新規プロジェクトの作成

「BackroomsHole」というプロジェクト名で新規プロジェクトを作成します。  
異なるプロジェクト名の場合はパッケージ化（配布用のEXEファイルなどの作成）などで設定ファイルの書き換えなどが必要になる場合があるかもしれません。

ここではプロジェクトフォルダが「D:\Works\UnrealProjects\BackroomsHole」に作成されたものとして説明します。  

https://docs.unrealengine.com/5.1/ja/creating-a-new-project-in-unreal-engine/  

作成するプロジェクト設定は「Games」の「Blank」で、「Project Defaults」は次のようにします。  

*Blurprint  
*Target Platform: Desktop  
*Quality Preset: Maximum  
*Starter Content: オフ（チェックなし）  
*Raytracing: オン（チェックあり）  

作成後にそのプロジェクトをUnreal Engineのエディタで開いている場合は閉じます。  

GameInstanceやGameModeなどに依存しているため、既存のプロジェクトに追加するのは難しいです。  
ただし個々の機能（インタラクトやダイアログ、通知など）は依存性が低くなるよう独立して作るようにしているので、一部機能だけを使用することもできるとは思います。  
この場合はそれなりのプログラミング知識などが求められます。  

## 3. BackroomsHoleのソースコードでプロジェクトを上書き

プロジェクトフォルダの直下にConfigフォルダとContentフォルダとPlatformsフォルダ（Platformsフォルダのみプロジェクトの設定などによっては作成されていない場合があります）があると思いますので、ダウンロードしたソースコードの同名フォルダをドラッグ＆ドロップなどで上書き保存します。  

*D:\Works\UnrealProjects\BackroomsHole\Config  
*D:\Works\UnrealProjects\BackroomsHole\Content  
*D:\Works\UnrealProjects\BackroomsHole\Platforms  

## 4. プロジェクトをUnreal Engineエディタで開く

以上でBackrooms Holeの導入は完了です。  

ゲームを改造してオリジナルのゲームを作成しても良いですし、まずはそのままパッケージ化（配布用のexe化）しても良いでしょう。  

# パッケージ化

パッケージ化のターゲットとなるプラットフォームによって、Unreal Engine以外にもインストールが必要なものがあるかもしれません。  
パッケージ化のための環境構築や手順は公式サイトやその他の解説等を参考にしてください。  

こちらではWindows向けのパッケージ化しか行っていないため、他のプラットフォーム向けのパッケージ化が可能かどうかすら不明です。

初回パッケージ化時やパッケージ化設定によってはコンパイルに何時間も掛かる場合があるかもしれません。  

## プロジェクト名が「BackroomsHole」以外でのパッケージ化

プロジェクト名が「BackroomsHole」以外の場合にパッケージ化する際に、「WARNING」が表示されることを確認しています。  

Config\Tags\Backrooms.iniファイルの「+AllowedConfigFiles=BackroomsHole/Config/Tags/Backrooms.ini」の行の「BackroomsHole」を現在のプロジェクト名に書き換えれば大丈夫だと思います（WARNINGのメッセージで同様の指示があると思います）。  

# 多言語対応

このゲームでは日本語と英語に対応しています。  

これはUnreal Engineのローカライゼーションツールを使って対応させています。  
https://docs.unrealengine.com/5.1/ja/localization-tools-in-unreal-engine/  

エディタ上で言語の切替の動作確認を行う場合は「スタンドアローンゲーム」としてプレイする必要があるようです。  


なお英語への翻訳は大雑把なものですので、必要に応じて各々で再翻訳などを行ってください。  

# フォント

Unreal Engine標準のフォントは日本語対応にはなっていますが、若干、日本人からすると不自然な感じものがあります。  

フォントをゲームに組み込むことも可能ですので、余力があればご自身のゲームに組み込んでも良いと思います。  

# プログラムの構成

共通システムの基本ファイルは「Content\LelouFW」フォルダに入っており、ファイル名が「LelouFW_」からはじまります。  

ゲーム固有のファイルは「Content\BackroomsHole」フォルダに入っており、ファイル名が「Yndrr_」からはじまります。  
基本的に基本ファイルを直接使わずに、それらのクラスを継承して使っています。  

例えばUserWidget（UI）はゲームによってレイアウトなどが大幅に異なるため、親クラスとなる基本ファイルではロジック的共通処理だけ実装しておき、子クラスとなるゲーム固有ファイルでは表示向けやゲーム固有の処理を実装することが多いと思います。  
なおゲーム固有ファイルの中には基本ファイルを継承していても全くオーバーライドを行っていないものもあります。  

機能追加や仕様変更を行うような場合以外は、基本的にゲーム固有ファイル（「Yndrr_」からはじまるファイル）のみ編集すれば良いと思います。  

## レベル（マップ）

3つのレベルので構成されています。  

1. 起動画面  
2. ゲーム本編  
3. クリア画面  

### 起動画面

Content\BackroomsHole\Level\Yndrr_Level_TopMenu  

基本的にトップメニュー（Content\BackroomsHole\Blurprint\Widget\UserWidget\TopMenu\Yndrr_WBP_TopMenu）を表示するだけのレベル。  

### ゲーム本編

Content\BackroomsHole\Level\Yndrr_Level_BackroomsHole  

このレベルに他の3Dモデルを配置するなどしていけば、オリジナルのマップにゲームが変わります。  

### クリア画面

Content\BackroomsHole\Level\Yndrr_Level_Ending  

エンドロール（Content\BackroomsHole\Blurprint\Widget\UserWidget\Yndrr_WBP_Ending）を表示するだけのレベル。  

2回目以降はエンドロールをスキップできるようになるので、スキップ機能のサンプルとして活用できるかもしれません。  

## GameInstance

Content/BackroomsHole/Blurprint/GameInstance/Yndrr_BP_GameInstance  

Unreal Engineの仕様として、GameInstanceはゲームの起動時に実行され、それがゲーム終了まで使われます。  
他のクラス（ControllerクラスやCharacterクラスなど）に関してはレベル遷移時などに終了し、新たに実行される仕様になっています。  

そのため環境設定などのセーブデータの保持などを中心に実装しています。  
他にもレベル遷移もGameInstanceで管理させています。  

## GameMode

### Yndrr_BP_GameMode

Content\BackroomsHole\Blurprint\GameMode\Yndrr_BP_GameMode  

このゲーム固有の基本となるGameModeで、起動画面とクリア画面で使っています。  

これらはUI（UserWidget）表示用の画面のため、キャラクターが不要なので「Defalt Pawn Class」を「None」にしています。  
他にも「HUD Class」も使わないため「None」にしています。  

ただし「Player State Class」は一部の処理で必要になる実装にしているため「Yndrr_BP_PlayerState」（Content/BackroomsHole/Blurprint/PlayerState/Yndrr_BP_PlayerState）を指定しています。  

### Yndrr_BP_GameMode_Gameplay

Content\BackroomsHole\Blurprint\GameMode\Yndrr_BP_GameMode_Gameplay  

このゲームの本編で使用するGameModeで、キャラクターなどを指定しています。  

ゲーム本編では「Player Controller Class」「Player State Class」「HUD」「Default Pawn Class」それぞれこのゲーム用のものを指定います。  

このゲームを雛形として別のゲームを作るような時にキャラクターを変更する場合は、ここの「Default Pawn Class」に使用するキャラクターのクラスを指定します。  

## ポーズメニュー（一時停止）

Content/BackroomsHole/Blurprint/Widget/UserWidget/Pause/Yndrr_WBP_Pause  

基本的にゲーム本編プレイ中はいつでも一時停止可能です（インベントリ表示中などではできないようにするなどの制御は行っています）。  

ポーズメニューにはセーブメニューのボタンがあり、いわゆるクイックセーブのようなことができる実装になっていますが、ポーズメニューからセーブメニューのボタンを削除することで無効にできます。  
セーブメニューボタンはグラフ（イベントグラフ）で使用しているため、イベントグラフ内でそのボタン（変数）を使用している箇所も取り除く必要があるかもしれません。  

## セーブ機能

Content/BackroomsHole/Blurprint/SaveGame  

セーブ機能はUnreal Engine標準のSaveGameクラスによる実装を行っており、3つの種類のデータを管理しています。  

* Settings（環境設定）  
* Achievement（ゲームクリア情報などの実績）  
* Gameplay（フラグなどプレイ中のゲームの進行情報）  

### Gameplayセーブデータ

Gameplay（ゲーム本編）のセーブデータに関しては複数のセーブスロットに対応していますが、GameInstanceが保持するGameplayのセーブデータは1つになっています。  
ゲーム本編を開始する時にロードするセーブデータをGameInstanceに渡すような仕様になっています。  

#### Gameplayのカスタムセーブスロット

ユーザーが任意のセーブをするためのカスタムセーブスロット数は Content/BackroomsHole/Blurprint/SaveGame/Yndrr_BP_SaveGame_ActorComponent のCustoms変数の値から変更できます。  
スロット数を増やしすぎるとセーブメニューやロードメニューの表示で調整が必要になる場合があります。  

オートセーブも無効にする場合は、ロードメニュー（ Content/BackroomsHole/Blurprint/Widget/UserWidget/GameplaySaveGame/Yndrr_WBP_GameplaySaveGame_Load ）からコンテニュー（オートセーブスロット）ボタンを削除します。  
コンテニューボタンはグラフ（イベントグラフ）で使用しているため、イベントグラフ内でそのボタン（変数）を使用している箇所も取り除く必要があります。  

# キャラクター

Content/BackroomsHole/Blurprint/Character/Yndrr_BP_Character_FirstPerson  

ソースコードを公開するため著作権・ライセンスも考慮して、キャラクターの3Dモデルやアニメーションが不要なファースト・パーソン・キャラクター（FPS視点）で実装しました。  

またキャラクターはゲーム毎に変更する可能性も高いと思われるため、キャラクターが確定していない段階でも開発を進めやすいように、キャラクターの操作やステータスなどはPlayerControllerやPlayerStateなどで行う実装にしています。  
キャラクターは見た目やアニメーションなどを主に実装するだけで、それ以外の操作やステータスなどはキャラクター以外で実装するイメージです。  

キャラクターを変更はGameModeの「Default Pawn Class」で行えます。  
キャラクターの移動など基本的な動作は、キャラクターを変更するだけでそのままある程度行えることがあります。  

## キャラクターの操作受付（Enhanced Input）について

このゲームプログラムではキャラクターの操作受付をPlayerController側で実装しています。  

他のゲーム開発でも流用することを前提に想定していることもあり、ゲーム毎にキャラクターは変更する可能性が高いとの判断から、変更する可能性が低めのPlayerController側で実装する方針にしました。  

そのため、基本的にはキャラクターではイベント・関数を実装しません。  

もし変更するキャラクターにイベント・関数などを実装済みの場合は、次のキャラクターの操作の箇所を削除します。  

* カメラ（AddControllerYawInput/AddControllerPitchInput）  
* 移動（AddMovementInput）  
* ジャンプ（Jump/StopJump）
* しゃがみ（Crouch/UnCrouch）  
* スプリント（ダッシュの処理は実装方法がキャラクターによって大きく異なります）  

例えばUnreal Engine標準のThirdPersonCharacterの場合であればキャラクターの操作の実装しかないので、イベントグラフに実装されているイベントをまとめて削除できます。  
削除が不安な場合は、各イベントノードの右上のノードリンクを切断します。  

なおキャラクターの実装によってはカメラや移動などに標準のノードを使っていないことがあり、その場合はそのイベントがキャラクター側からはコントローラー操作では実行されないように適当な名前でカスタムイベントとして実行できるようにします。  
そしてPlayerController側でカメラや移動の操作時に、そのカスタムイベントを実行するようにオーバーライドします（このオーバーライドをしないと標準のノードを使うので、想定される本来のキャラクターの動作が行われない場合があります））。  

# コントローラー

Content/BackroomsHole/Blurprint/Controller/Yndrr_BP_PlayerController  

キャラクターの操作から一時停止やインベントリの操作など、ゲームパッド・キーボード・マウスの入力の受付は基本的にこのコントローラーで実装しています。  

入力受付はUnreal Engine標準のEnhanced Inputを使用しています。  
Content/LelouFW/Input  

UIなどで操作に対応するボタンをアイコンで表示していますが、これはUnreal Engine標準のCommon Input Settingsで実装しています。  
Enhanced Inputの入力を変更する場合は、このアイコン設定もそれに合わせて変更する必要があるかもしれません。  
Content/LelouFW/Blurprint/Widget/CommonUI/LelouFW_CommonUI_CommonInputBaseControllerData_MouseAndKeyboard  
Content/LelouFW/Blurprint/Widget/CommonUI/LelouFW_CommonUI_CommonInputBaseControllerData_Gamepad  

なおエンドロール（ Content/BackroomsHole/Blurprint/Widget/UserWidget/Yndrr_WBP_Ending ）のスキップ機能はこのコントローラーでの入力受付を行わず、UserWidget側で入力受付を行っています。  
これはスキップ機能のサンプルとして流用しやすいように依存関係を極力持たせないようにしたためです。  

# HUD

Content/BackroomsHole/Blurprint/HUD/Yndrr_BP_HUD  

HUDは次のUserWidgetを扱っています。

* ダイアログ  
* 通知  
* アクション  
* 一時停止  
* ActorViewer  
* インベントリ  
* ズームイベント  
* レティクル  
* ズーム中テキスト  
* セーブメニュー  

HUDの解釈・定義・方針などによってはHUDで管理すべきでないものありますが、現時点では開発のしやすさなどを考えて色々なクラスからアクセスする可能性が高いUserWidgetをHUDで扱う実装にしています。  

# GameState

このゲームでは使用していません。  

# PlayerState

キャラクターの情報も含め、ゲームの進行状況などをPlayerStateで管理する実装にしています。  

# 環境設定

Content/BackroomsHole/Blurprint/Settings/Yndrr_WBP_Settings  

環境設定には次の項目があります。  

* 言語  
* カメラの揺れ  
* 画面中心点（クロスヘア・レティクル）  
* 画面モード／解像度  
* フレームレート上限  
* 垂直同期  
* 画質  
* 明るさ  
* モーションブラー  
* BGM音量  
* 効果音音量  
* ボイス音量  
* カメラ感度  
* カメラ入力方向（水平）  
* カメラ入力方向（垂直）  
* コントローラー振動  

言語や画質に関連する項目は基本的にUnreal Engineの標準機能として自動的にセーブされています。  
それ以外の項目は環境設定用SaveGame（ Content/BackroomsHole/Blurprint/SaveGame/Settings/Yndrr_BP_SaveGame_Settings ）に保存しています。  

ゲームによっては不要な項目もあるでしょうから、その場合はその項目を削除してください。  
削除しただけだとコンパイル時にエラーが出ると思いますが、グラフ（イベントグラフ）からもその項目を使用している箇所を削除します。  
なお削除した項目が環境設定用SaveGameにある場合でも、そのSaveGameまで修正（該当する項目の削除）しなくても問題ありません。  

このゲームのサウンドは効果音のみでBGMとボイスはありませんが、サンプルとしてそのまま項目を残して実装しています。  

## レベル・ヘルパー・アクター

Content/BackroomsHole/Blurprint/Actor/LevelHelper/Yndrr_Actor_LevelHelper  

レベル・ヘルパー・アクターは原則、1つのレベルに1つを配置します。  
何かを表示するものではないため、場所はどこでも良いです。  

このアクターでは主に画質・ポストプロセス・明るさを管理をします。  
そのため、そのレベルにはポストプロセスボリュームも1つ以上配置します。  

また特定のレベル用に処理を行いたい場合はそれ用にレベル・ヘルパー・アクターの子クラスを実装し、その子クラスでレベルに配置します。  

これらの処理はレベルブループリントで実装するのが自然かもしれませんが、レベルブループリントは継承できないようでどのレベルでも共通に行うような処理の実装が不便のため、それ用のアクタークラスで対応する実装にしました。  

### 画質設定: QualityMapping（マップ型＜Integer⇒LelouFW_Struct_Settings_Quality＞）

レベル・ヘルパー・アクターのQualityMapping変数で画質の調整ができます。  

Integer型をキーとするマップ（連想配列）で、このキーは環境変数の画質と次のように紐づいています。  

* 1 = 最低画質  
* 3 = 低画質  
* 5 = 標準
* 7 = 高画質  
* 9 = 最高画質  

既定値は全体的に画質重視に設定しており、最低画質でも負荷は比較的高いと思います。  
画質より快適さを優先する場合は、必要に応じて画質設定を調整してください。  

設定項目はUnreal Engine標準のゲームのユーザー設定（GameUserSettings）で指定できる主な項目とポストプロセス設定です。  
Content/LelouFW/Blurprint/Actor/LevelHelper/LelouFW_Struct_Settings_Quality  

## カスタムアクター

Content/BackroomsHole/Blurprint/Actor/Yndrr_BP_Actor_Base  

このクラスはActorを継承した子クラスで、次のような処理を実装しています。  

* インタラクト  
* ActorViewer  
* インベントリ  
* 通知  
* ダイアログ  
* ズームイベント  
* ドア・引き出しの開閉  
* セーブ  
* コントローラー振動  
* 一時停止イベント  

このゲームで使用するアクターをこのクラスを継承した子クラスにすることで、色々な処理をアクターに実装可能になります。  
アイテムもドアも家具もこのクラスの子クラスにします。  

当然、開閉処理が不要なアイテムなどにも実行されないだけで開閉処理を持つことになりますし、逆にドアや家具などはインベントリに追加されることがないのにそれらの処理を持つことになります。  

ゲームによっては1つのレベルに何百以上も配置することもあるかもしれませんから、時にはこの肥大化したクラスがゲームプレイのパフォーマンスに大きな影響を与える可能性はあります。  
そのためプログラミング的には極力必要な処理だけを持た方が良いとも言えます。  

ですがこのゲームでは開発効率を優先して、何かしら共通処理を使用するようなアクターは原則としてこのカスタムアクターの子クラスにする方針にしています。  
こうすることで例えばインベントリのシステムを変更するような場合でも、ここのアクターを修正することなくベースとなるカスタムアクタークラスを変更するだけで仕様変更に対応できるようになります。  

ゲーム開発に限らずシステム開発では途中からシステム全体に影響する仕様変更が入ることは珍しくありません。  
理想は設計段階から仕様を固めてしまうことかもしれませんが、ゲーム開発であればテストプレイをしてからゲームを遊びやすくするため面白くするために仕様変更が求められることもあるでしょうし、プログラミングやシステム開発の理想のために遊びやすさや面白さを犠牲にするのは手段が目的になってしまっているように思います。  

そのためスマートフォンなど低スペック端末でのプレイにも対応させるゲームの場合はこのカスタムアクターの細分化などの調整を行う必要があるかもしれません。  

なお変数などで使わない処理の初期処理を行わない、処理を実行する時に初期処理を行うなど、ある程度の負荷軽減を意識した実装は行ってはいます。  


## インタラクト

Content/BackroomsHole/Blurprint/Interaction/Yndrr_BP_Interaction_ActorComponent  

アイテムを拾ったりドアを開けたりといった探索要素・ウォーキングシミュレーター要素があるようなゲームではほぼ必須となる機能です。  


2つの条件を満たした時にインタラクトできるような仕様になっています。  

1つは範囲で、個々のカスタムアクターが持つインタラクトの範囲用コリジョンをキャラクターが触れたかどうかです（Overlapしているか）。  
2つ目は見る距離と角度で、そのカスタムアクターがもつインタラクトの見ている確認用コンポーネントを見ている距離と角度が条件内に収まっているかどうかです。  


1つ目の条件を満たしている間のみ、2つ目の条件のチェック（ループ処理による常時監視）を行います。  

そのため例えばアイテムやドアの近くにいても、アイテムそのものやドアノブなどをキャラクターカメラが捉えていないとインタラクトできない仕様になっています。  

また2つ目の条件の距離を満たさない時でも1つ目の条件を満たしているかの判別はできるため、必要に応じてインタラクトできるアイコンなどを表示することで、ユーザーに対して近くにインタラクト対象があるというヒントを伝えることができます。  

### インタラクト設定

カスタムアクターの変数からアクター毎にインタラクト設定が可能です。  

#### インタラクト設定用変数: UseInteraction（Boolean型）

既定値: False  

デフォルトではインタラクトを無効にしているので、インタラクト可能なアクターのみこの設定を有効（チェックボックスにチェックを入れる）にします。  

インタラクトが不要なアクターで有効になっていると、インタラクトしているかどうかの判別処理が無駄に行われるので注意してください。  

#### インタラクト設定用変数: UseInteractHints（Boolean型）

既定値: True  

1つ目の条件を満たしている段階でインタラクト対象があることをユーザーに伝えるためのアイコンを表示するためのものです。  

UseInteractionとUseInteractHintsの両方が有効な場合に、1つ目の条件を満たしている間のみ表示されます。  

#### インタラクト設定用変数: IntaractionOrientationDistance（Float型）

既定値: 150

2つ目の条件の距離の設定になります。  

大きすぎると不自然な距離からインタラクトできてしまうので注意してください。  

#### インタラクト設定用変数: IntaractionOrientationRange（Float型）

既定値: 15

2つ目の条件の角度の設定になります。  

小さすぎるとカメラの中央で対象を捉えている間のみしかインタラクトできないので注意してください。  
カメラ操作はピンポイントで正確な操作は難しいです。  

逆に大きすぎると視覚野によってはカメラで捉えられていない場合でもインタラクトできてしまいます。  
インタラクトボタンを連打しながらプレイするユーザーもおり、インタラクトによるイベントでもそのユーザーは何を行ったのか理解できない恐れがあります。  

#### インタラクト設定用関数: GetInteractionOverlapAreas

既定返り値: InteractionOverlapCollision

1つ目の条件となるコリジョンを変更・追加する場合は、子クラスでこの関数をオーバーライドします。  

1つ目の条件の範囲のTransform（位置・回転・大きさ）は、この関数が返すコリジョンをアクター上もしくはレベル上で調整できます。  

例えば壁側にアクターを配置する場合は、部屋の外などからそのアクタをインタラクトできないようにコリジョンのTransformを調整してください。
他にも時計など高い位置に配置するアクターの場合は、そのコリジョンの位置や大きさを調整しないとインタラクトできない場合があります。  

#### インタラクト設定用関数: GetInteractionOrientationAreas

既定返り値: InteractionOrientationCollision

2つ目の条件となるコンポーネントを変更・追加する場合は、子クラスでこの関数をオーバーライドします。  

サンプルとしてドア（Content/BackroomsHole/Blurprint/Actor/Door/Yndrr_BP_Actor_Door_Base）で既定の返り値を無視し、ドアノブのコンポーネントを返すようにオーバーライドしています。  
これによりドアの開閉状況に関わらず、ドアノブの位置でインタラクト可能になります。  

ちなみにここまで細かい実装にしなくても、既定のコンポーネントのままでドアの中央付近に表示し、IntaractionOrientationRange変数を大きめに設定しても良いと思います。  
逆にこの方がドアを開閉する時にインタラクトする場所が同じで便利とも言えます（ドアノブをインタラクト対象にすると、ドアの開閉によってインタラクト対象が移動してしまう）。  

#### インタラクト設定用関数: GetInteractionSymbols

既定返り値: InteractionSymbol

1つ目の条件を満たした時に表示するアイコンを変更・追加する場合は、子クラスでこの関数をオーバーライドします。  

サンプルとしてドア（Content/BackroomsHole/Blurprint/Actor/Door/Yndrr_BP_Actor_Door_Base）で既定の返り値を無視し、ドアノブに表示するアイコンを返すようにオーバーライドしています。  
これによりドアの開閉状況に関わらず、ドアノブの位置に表示されるようになります。  

さらにサンプルとして両開きのドア（Content/BackroomsHole/Blurprint/Actor/Door/Yndrr_BP_Actor_Door_HingedDouble）では、ドアの開閉状態によって表示するアイコンの切替も行っています。  
これにより閉じている時は2つのドアの中央に、開いている時は両方のドアのノブにそれぞれアイコンを表示されるようになっています。  

ただ実装が複雑になるため、ここまで細かい仕様にしなくても問題はないと思います。  

## Action

Content/BackroomsHole/Blurprint/Action/Yndrr_WBP_Action  

インタラクトしている時に「拾う」や「ドアを開ける」といったアクションを管理するものです。  
ドアに対して「開ける」や「鍵を掛ける」といったアクションが複数ある場合や、インタラクトできるアクターが近くに集まっている場合でも、複数のアクションを管理することができます。  

### Actionの使い方

インタラクトされた時（2つの条件を両方満たした時）に「拾う」や「ドアを開ける」といったアクションができるようにしたいカスタムアクターのGetActionGameplayTags関数をオーバーライドして、実行可能なアクションのフラグとアクション名を返します。  
このアクションはマップ型でフラグ（GameplayTag型）をキーに、アクション名（Text型）が値になっており、複数設定することも可能です。  

このアクションマップの他に優先度（Priority）も設定でき、複数のアクターが同時にインタラクトされた時はこの値が大きいアクターのアクションマップから順番に表示されます（例えば引き出しが複数ある場合、下の引き出しから優先的に開けれるようになっている方がユーザーにとっては便利です）。  

条件分岐などを使うことで、ドアの開閉状態に応じてアクションマップを切り替えるといったこともできます。  


なおカスタムアクターがインタラクトされると自動的にAction機能がそのアクターを調べ、そのアクションを表示します。  
複数のアクションがある場合はユーザーがアクションを切り替えて選択できるようなUIになります。  

そしてユーザーによってアクションが選択されると、その対象となるカスタムアクターのRequestActionイベントが実行されます。  
このイベントの第1引数のGameplayTagで選択されたアクションのフラグ（GameplayTag）がわかるので、アクションによって処理を実行したいカスタムアクターでこのオーバーライドしてドアを開けるなどアクションに該当する処理を実装します。  


また別カスタムアクターでアクションが実行された時に処理を行いたいような時は、カスタムアクターのUpdateGameplayTagイベントをオーバーライドすることで可能になります。  
このフラグはゲームシステム全体で使用しているため、第1引数のAddedGameplayTagには別のカスタムアクターでのアクション実行時以外のフラグが入っている場合があります。  

ただフラグ（GameplayTag）が一意になるように管理・設定することで、他のカスタムアクターなどに依存することなく柔軟な実装が可能になるかと思います。  

このイベントを活用することで、照明アクターが別アクターである照明スイッチが押された時に照明のオンオフを行うといったことが可能になります。  
他にもドアアクターが別アクターがインベントリに追加された時に連動してドアが閉まるといったことも可能になります。  

#### アクションフラグのセーブ・ロード

カスタムアクターのSaveイベントを実行すると、その時点のゲームシステム全体で管理しているGameplayTagのリストが保存されます。  
そしてロードゲーム時にこのリストが各カスタムアクターの初期処理時にBindLoadedGameplayTagsイベントの第1引数のGameplayTagsに渡されます。  

ロードゲーム時に必要に応じてそのリストに応じて、各カスタムアクターでロードの復帰処理を実装することが可能です。  

ただしカスタムアクターの初期処理はその時のアクションの実行順に行われるわけではないですし、ドアの開閉などでは復帰処理時にアニメーションや音があると不都合があるので実装には注意してください。  

ロードの復帰処理はバグの原因になりやすいので、ゲームの仕様や規模などによってはセーブ・ロード対象を整理したり、セーブ・ロード機能自体をなしにしたりといった判断も大切かと思います。  
例えばドアの開閉状態などゲーム本編に影響の少ないものに関してはロード対象から外しても大きな問題はないと思います。  

そもそも長編ゲームでもなければセーブ・ロード機能は使われないこともありますし、エンド回収などでゲームを周回する場合でもドアの開閉状態の復帰まで求めるユーザーは少数だと思います（フルプライスゲームとかなら値段分の作り込みを求められやすいかもしれませんが）。


サンプルとしてこのゲームのドア（Content/BackroomsHole/Blurprint/Actor/Door/Yndrr_BP_Actor_Door_Base）でRequestActionイベントとBindLoadedGameplayTagsイベントでセーブ・ロード処理を実装しています。  

## ActorViewer

Content/BackroomsHole/Blurprint/ActorViewer/Yndrr_WBP_ActorViewer  

ActorViewerとはカメラの正面に表示して360度から見ることができる機能になります（一般的な名称がわからなかったため暫定的に「ActorViewer」という名称にしています）。  

リアルの世界で物を手に持って調べる行為を擬似的にゲーム内で表現するような機能で、「回転」「拡大縮小」「移動」の操作が可能です。  
「移動」は、大きく拡大した時にアクターの中央以外が見えにくくなるのでそれを補助する機能で、レベル上のアクターの位置を移動させるための機能ではありません。この機能を終了させた時に元のTransform（位置・回転・大きさ）にアクターは戻ります。  

### ActorViewerの制限

ActorViewerには現在2つの制限があります。  
これは私の知識・技術的な課題によるものです、知識・技術がある方はご自身で修正することでこの制限を回避できるかと思います。  


1つ目は表示対象をカスタムアクター内の「ActorViewerScene」の配下に置く必要がある制限です。  

そうでないと、ワールドを基準とした絶対位置で「回転」「移動」が行われてしまいます。  
特に「移動」で大きな問題が発生し、キャラクターが向く角度によって「左右の移動」が「前後の移動」になってしまいます。  

「回転」に関しては「左右の回転」と「上下の回転」がコントローラーの動きと反対になってしまいますが、実用上の致命的な問題は発生しないとは思います。  

この制限は私の知識・技術が不足しているためで、恐らくカメラの位置を基準に「回転」「移動」の処理を実装する方法はあると思います。  

[Horror Engine](https://www.unrealengine.com/marketplace/ja/product/horror-engine)というアセットでこの処理を実装しているようだったのですが、私ではその実装方法がわからなかったので、暫定的に現在はこのような仕様（制限）で実装しています。  

なお操作処理自体はContent/BackroomsHole/Blurprint/ActorViewer/Yndrr_BP_ActorViewer_Modelで実装しており、制限が不要になる仕様変更を行った場合でも、既存のアクターは修正不要で従来通りに動作させることができるとは思います。  


2つ目はアクターの遅延表示です。  

移動中にActorViewerを表示するとキャラクター（カメラ）が止まるまでの遅延があるため、それを考慮してアクター表示直後にも遅延処理でアクターを再表示しています。  
実用上特に問題はありませんが、表示直後の回転・拡大縮小・移動などの操作は再表示時にリセットされます。  

ActorViewer表示直後にキャラクターを強制的に静止させる仕様だと、影や鏡でキャラクターが見えるタイプのFPSの場合などでは不自然さが出る可能性があります。  

またActorViewerはインベントリの表示でも使っており、そのアクターが配置されている位置からカメラの正面の位置までをアニメーション的に移動させる仕様にする場合は、インベントリ用にカメラの下から表示させるなどの処理を切り替える必要になるかもしれません。  

現時点では実用上無視できるものと判断し、暫定的に現在の仕様（制限）にしています。  

### ActorViewerの使い方

ActorViewerで表示するアクターのShowActorViewerイベントを実行することで、そのアクターがActorViewerで表示されます。  
レベルブループリントや他のアクターなどからそのアクターを表示する場合は、そのアクターのインターフェースイベントの「ShowActorViewerFromActor」を実行することで表示されます（このインターフェースイベントはShowActorViewerイベントのラッパーイベントになっており、実質的に同じイベントです）。  

### ActorViewer設定

### ActorViewer設定変数: ActorViewerScale（Float型）

既定値: 0.5

ActorViewerで表示する時の初期スケール（大きさ）を設定できます。  

レベル上に配置したままの大きさだとアクターによって小さすぎたり大きすぎたりして見えづらい場合があります。  
必要に応じて表示時の大きさを調整します。  

実用的かは別にして、車など大きなものもActorViewerで表示可能です。  

### ActorViewer設定変数: ActorViewerRotator（Rotator型）

既定値: X=0.0 Y=0.0 Z=0.0

ActorViewerで表示する時の初期角度を設定できます。  

真正面からの表示だと見えづらいものあるので、必要に応じて角度を調整します。  

## インベントリ

Content/BackroomsHole/Blurprint/Inventory/Yndrr_WBP_Inventory  

シンプルなインベントリ機能のため、ゲームの仕様によってはインベントリは独自に実装が必要になると思います。  

### インベントリの使い方

設定としてインベントリに追加可能なカスタムアクターでは2つの事を行います。  

1つ目にAddInventoryGameplayTag変数（GameplayTag型）にインベントリ追加用の一意の識別用フラグを設定します。  

2つ目にインターフェースとしてContent/BackroomsHole/Blurprint/Actor/Yndrr_BPI_Actor_Inventory_Use_Interface を設定します。  
親クラス側で既に設定している場合は子クラス側での設定は不要です。  

これら2つを設定を行っておくことで、セーブロード時に自動的にインベントリ内のアイテムが復元されるようになります。  

そしてインベントリに追加するカスタムアクターのAddInventoryイベントを実行することで、そのアクターがインベントリに追加されます（追加されるとそのアクターはレベル上に表示されなくなります）。  
レベルブループリントや他のアクターなどからそのアクターをインベントリに追加する場合は、そのアクターのインターフェースイベントの「AddInventoryAtActor」を実行することで追加されます（このインターフェースイベントはAddInventoryイベントのラッパーイベントになっており、実質的に同じイベントです）。  


## 通知

Content/BackroomsHole/Blurprint/Notice/Yndrr_WBP_Notice  

通知機能はゲームシステムの補助的な機能で、アイテムをインベントリに追加した時などに画面右上に一定時間メッセージを表示する機能です。  

通知機能そのものはHUDとして実装していますが、カスタムアクターから簡単に使えるようになっています。  

### 通知の使い方

カスタムアクターのShowNoticeイベントを実行するだけです。  

第1引数のMessage（Text型）に表示する文言を指定します。  
第2引数のDuration（Float型）に通知を表示する秒数を指定します。  
第3引数のID（Name型）は複数の通知があった時用などに個別の通知を識別するための管理用になります。

例えばインベントリに追加を行った場合は、標準で「インベントリに更新あり」といったメッセージを5秒表示するようになっています（第3引数のIDは「UpdatedInventory」のような簡単なもので基本的には問題ありません）。  

## ダイアログ  

Content/BackroomsHole/Blurprint/Dialogue/Yndrr_WBP_Dialogue  

Unreal Engine標準でダイアログ機能は用意されていますが、個人的に使いにくかったのでオリジナルのダイアログシステムを実装しています。  

ダイアログ機能そのものはHUDとして実装していますが、カスタムアクターから簡単に使えるようになっています。  

### ダイアログの書式

Content/LelouFW/Blurprint/Dialogue/LelouFW_Structs_Dialogue  

ダイアログは構造体のLelouFW_Structs_Dialogueを行とするデータテーブルになっており、次の項目があります。  

* Subtitle（セリフ / Text型）  
* Sound（ボイス / SoundBase型）  
* Speaker（話し手識別用フラグ / GameplayTag型）  
* DirectedAt（話し手の対象識別用フラグ / GameplayTag型）  
* GameplayTag（フラグ用 / GameplayTag型）  

セリフ・ボイス以外はオプション・カスタマイズ要素で、Speakerのフラグを判別して話し手のキャラクター画像を表示したり、キャラクター自体をアニメーションさせたりといった処理を実装できます。  

サンプルとしてNewGame時に主人公が話すタイミングで画像の表示・切替を行っています。  
単に話者の判別だけでなく、その話者と話し方などを設定でフラグ管理することで幅広い表現も可能です。  

GameplayTag自体を管理することで、特定のセリフのタイミングでドアが勝手に閉まるといったイベントを発生させることも可能です。  

なおダイアログは閉じるまで前後に行き来可能なため、会話によってイベントを実行する場合は1回だけ実行されるようにするなどの実装が必要になります。  
DoOnceノードを使うことで比較的容易に1回だけ実行する処理を実装できるのではないかと思います。  

なお会話中に選択肢を表示するような機能は実装していません。  
このような機能が必要な場合はご自身でカスタマイズが必要になります。  
ダイアログのOnChangedDialogueイベントディスパッチャーなどからダイアログを閉じたタイミングでイベントを実行可能なので、その時に使われていたデータテーブル（会話ファイル）などを判別して選択肢のUI（UserWidget）を表示するといった感じで簡易的に選択肢表示に対応できるかもしれません。  

### ダイアログの使い方

カスタムアクターのShowDialogueイベントを呼ぶだけです。  

第1引数のDataTable（DataTable型オブジェクト参照）に会話ファイル（データテーブル）指定します（事前に作成）。
第2引数のAuto（Boolean型）がTrueの場合は次の行がある場合は自動で次の行へ進み、ない場合は自動でダイアログを閉じます。  
第3引数のTypewriterEffect（Boolean型）がTrueの場合は1つの行を一度に表示せず、1文字ずつ時間差でタイプ入力しているように表示します。  

ただしTypewriterEffectは一度表示した行を戻って表示した時は一度に表示します。  
これは文字数によりますが表示に若干時間が掛かるため、ユーザーによっては億劫に感じると判断してこのような仕様にしています。  

## ズームイベント  

カスタムアクターのZoomDialogue変数にダイアログ用のデータテーブルを指定しておくと、最大ズームとインタラクト（インタラクト条件を2つとも満たしている時）の両方を満たす時に、自動でそのダイアログが表示されます。  

特定のアクターをズームで見た時にダイアログとしてヒントを与えるといった使い方ができます。  


またカスタムアクターのWatchZoom変数（Boolean型）をTrueにして置くことで、同じように最大ズームとインタラクトの両方を満たす時に、BindZoomFinishingAndInteractingイベントが実行されます。  
対象となる子クラスでこのイベントをオーバーライドすることで、自由にイベントを実行することが可能になります。  

例えば窓ガラスに2つ目の条件のコンポーネントを設定しておき、その窓の近くでズームしながら外を見た時に窓の外に何かが現れたり、窓ガラスに手形がつくといった演出が可能になります。  
インタラクトとは違い、ユーザーからするとズームを条件としたイベントの発生は心の準備ができていないことがあり、不意打ちの演出としてより高い効果が期待できるかもしれません。  

## ドア・引き出しの開閉  

ドアの開閉時はカスタムアクターのPlayClosingイベントを実行します。  

第1引数のSecond（Float型）はドアの開閉処理のスピードで、何秒かけて開閉処理を行うかを指定します。  
第2引数のReverse（Boolean型）ではドアを開けるのか閉めるのかの切替を行います。閉める場合にTrueを指定することになるはずですが、ドアの作りによっては開ける時にTrueにする必要があるかもしれません。  

ただドアのフレームと実際に開閉するドアの板などの指定が複雑なので、ゲーム内のドア（ Content/BackroomsHole/Blurprint/Actor/Door/Yndrr_BP_Actor_Door_Single ）のフレームと板がどのように配置されているかなどを参考にしてください。 
特にドアノブの動きや両開きのドアにも対応させ、かつ開閉の開始時や終了時に音やコントローラー振動も実行する処理を実装しているため、単純なドアの開閉処理ですが実装は複雑なものになっています。  


また引き戸タイプのドアやタンスの引き出しの開閉は、カスタムアクターのStartSlideClosingイベントを実行します。  

第1引数（Float型）は開閉処理のスピードで、何秒かけて開閉処理を行うかを指定します。  
第2引数のReverse（Boolean型）ではドアを開けるのか閉めるのかの切替を行います。閉める場合にTrueを指定することになるはずですが、ドアの作りによっては開ける時にTrueにする必要があるかもしれません。  

スライドタイプの開閉処理はまだ単純ですが、ゲーム内の引き出し（ Content/BackroomsHole/Blurprint/Actor/Furniture/Yndrr_BP_Actor_Drawer_A ）を参考にしてください。  

### ドアの設定

ドアの基底アクター（ Content/BackroomsHole/Blurprint/Actor/Door/Yndrr_BP_Actor_Door_Base ）を継承してドアアクターを作ることで、ある程度の処理を変数の変更だけでドアを実装することができます。  

サンプルとして作っているドアはどれも、このドアの基底クラスを継承しています。  

鍵の識別にも対応しており、インベントリ内の鍵アクターインターフェース（ Content/BackroomsHole/Blurprint/Actor/Key/Yndrr_BPI_Actor_Key_Interface ）を実装しているアクターのKeyTags（配列＜GameplayTag型＞）を調べます。  

#### ドアの設定: OpenGameplayTag（GameplayTag型）

ドアを開ける用のGameplayTagを指定します。  

このGameplayTagは特定のドアを開ける専用となるように一意のものを指定します。  
他ドアや他のアクションと重複しているよう場合は、このドアを開く時に他のドアが一緒に開くなどの原因になります。  

#### ドアの設定: CloseGameplayTag（GameplayTag型）

ドアを閉める用のGameplayTagを指定します。  

このGameplayTagも一意になるように指定します。

#### ドアの設定: UnlockGameplayTag（GameplayTag型）

ドアの解錠用のGameplayTagを指定します。  

このGameplayTagも一意になるように指定します。

#### ドアの設定: LockGameplayTag（GameplayTag型）

ドアの施錠用のGameplayTagを指定します。  

このGameplayTagも一意になるように指定します。

#### ドアの設定: KeyTags（配列＜GameplayTag型＞）

個々のドアに対応する鍵を識別するためのGameplayTagの配列（リスト）で、そのドア専用の鍵の他にマスターキーにも対応させるといった感じで複数指定できます。  

この値が空の時はドアの解錠・施錠に鍵が不要になります（トイレのドアのように鍵が不要なタイプのドア用）。  

#### ドアの設定: Lock（Boolean型）

この変数がTrueの時、ドアは施錠されている状態になります。  

#### ドアの設定: AutoUnlock（Boolean型）

この変数がTrueの場合、ドアを開ける時に施錠されていても、鍵が不要かそのドア用の鍵を持っている場合は自動で解錠した上でドアを開けます。  

逆にこの変数がFalseの場合は、鍵の有無にかかわらず施錠されていると、ドアを開こうとしても施錠されたままで開くことができません。  

ゲームの仕様によってユーザー自身で解錠させるかどうかを設定できます。  

#### ドアの設定: CanLock（Boolean型）

この変数がTrueの場合、ドアが閉まっている時に、鍵が不要かそのドア用の鍵を持っている場合にドアを施錠することできます。  

### 鍵アクター

鍵の基底クラス（Content/BackroomsHole/Blurprint/Actor/Key/Yndrr_BP_Actor_Key_Base）を継承して鍵アクターを作ります。  

そしてKeyTags変数（配列＜GameplayTag型＞）にその鍵の識別用のGameplayTagを指定します。  
複数指定可能なので、1つの鍵で複数のドアに対応させるといったことが可能です。  

ドアアクターと鍵アクターのKeyTags変数で同一のものがある場合は、そのドアと鍵が対応していることを意味します。  

## コントローラー振動

カスタムアクターのPlayForceFeedbackイベントを実行するだけです。  

第1引数にForceFeedbackComponentを指定し、第2引数にStartTimeを指定するだけです。  

ほとんどUnreal Engine標準のコントローラー振動の処理をそのまま呼ぶだけなのですが、このイベントを2つのメリットがあります。  

1つは環境設定で設定したコントローラー振動の設定を反映できること。  
ユーザーによってはゲームパッドを使っている場合でもコントローラー振動を無効にしたい場合があります。  

2つ目はゲームの一時停止時にコントローラー振動が止まります。  
特に一時停止を考慮しないでコントローラー振動を実行する場合、その振動が終わっていない状態で一時停止が行われるとその振動状態が一時停止中も継続される場合があります。  

例えば誰かがドアを叩き続けている演出をしている時にユーザーが一時停止を行うと、その振動が一時停止を解除するまで継続することがあります。  
普通は一時停止中は振動も停止し、一時停止解除後にその振動が再開されるのが望ましいかと思います。  

## 一時停止イベント

カスタムアクターのWatchPause変数（Boolean型）がTrueにしておくと、ゲームの一時停止が切り替わった時にそのカスタムアクターのBindGamePausedイベントが実行されます。  

あまり使うことがないイベントかもしれませんが、サンプルとしてゲーム内の時計では、一時停止後に現在の時間を取得しなおしています。一時停止を考慮していないと、例えば10分間一時停止を行うとその時間分ゲーム内の時計が遅れます。  
Content/BackroomsHole/Blurprint/Actor/Clock/Yndrr_BP_Actor_Clock_Base
